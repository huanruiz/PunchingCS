# 排序算法
总结几大排序算法. 主要对比时间复杂度和空间复杂度. 下图是排序算法属性的总结. (表格中希尔排序的部分存疑)
|  算法  | 平均时间复杂度 | 最好情况 | 最坏情况 | 空间复杂度 | 排序方式 | 稳定性 |
|  ----  |    ----     |  ----  |  ----  |  ----  |  ----  |  ----  |
| 冒泡排序 |  $O(n^{2})$  |  $O(n)$  |  $O(n^{2})$  |  $O(1)$  |  内部  |  稳定  |
| 选择排序 |  $O(n^{2})$  |$O(n^{2})$|  $O(n^{2})$  |  $O(1)$  |  内部  |  不稳定  |
| 插入排序 |  $O(n^{2})$  |  $O(n)$  |  $O(n^{2})$  |  $O(1)$  |  内部  |  稳定  |
| 希尔排序 |  $O(nlogn)$  |  $O(nlog^{2}n)$  |  $O(nlog^{2}n)$ |  $O(1)$  |  内部  |  不稳定  |
| 快速排序 |  $O(nlogn)$  | $O(n^{2})$ |  $O(n^{2})$  | $O(logn)$ |  内部  |  不稳定  |
| 堆排序   |  $O(nlogn)$  | $O(nlogn)$ |  $O(nlogn)$  | $O(1)$ |  内部  |  不稳定  |
| 归并排序 |  $O(nlogn)$  | $O(nlogn)$ |  $O(nlogn)$  | $O(n)$ |  外部  |  稳定  |

接下来都以把一个array或者list从小到大排列为基准进行介绍.

## 冒泡排序
从前到后比较, 发现逆序则交换, 每次循环都把最大的值放到最后面. 考虑最坏的情况, 比如表示逆序的情况, 需要排序$1+2+...+(n-1) = \frac{n(n-1)}{2}$次, 所以时间复杂度是$O(n^{2})$. 最好情况就是已经有序, 遍历一次即可. 注意这里的flag可以稍微优化冒泡排序, 因为当子循环没有发生任何交换, 就代表剩下的数据已经成功排列了.
```
// Java(这个不标准, 因为没有两两比较. 效率也低, 每轮交换对数组其他元素没有排序的影响, 甚至不如选择排序)
public static void bubbleSort(int[] arr) {
    boolean flag;
    int temp;
    for (int i = 0; i < arr.length; i++) {
        flag = false;
        for (int j = i; j < arr.length; j++) {
            if (arr[i] > arr[j]) {
                temp = arr[j];
                arr[j] = arr[i];
                arr[i] = temp;
                flag = true;
            }
        }
        if (! flag) {
            return; // 一次交换都没有就退出
        }
    }
}
```

```
# Python(这个是标准的)
def bubblesort(arr):
    for i in range(len(arr) - 1):
        for j in range(len(arr) - i - 1):
            flag = True
            if arr[j] > arr[j + 1]:
                flag = False
                arr[j], arr[j + 1] = arr[j + 1], arr[j]
        if flag == True:
            return
```
## 选择排序
每一轮选最小值, 放在未排序的的首位. 不管数组顺序怎样, 比较的次数不变, 也就是$n(n-1)/2$, 所以时间复杂度是$O(n^2)$, 但交换移动的次数少, 所以可以说简单选择排序的性能略优于冒泡排序.
```
// Java
public static void selectionSort(int[] arr) {
    int temp = 0;
    for (int i = 0; i < arr.length - 1; i++) {
        int min_index = i;
        for (int j = i + 1; j < arr.length; j++) {
            if (arr[j] < arr[min_index]) min_index = j;
        }
        temp = arr[i];
        arr[i] = arr[min_index];
        arr[min_index] = temp;
    }
}
```

```
# Python
def selectionsort(arr):
    for i in range(len(arr) - 1):
        min = i
        for j in range(i + 1, len(arr)):
            if arr[j] < arr[min]:
                min = j
        arr[i], arr[min] = arr[min], arr[i]
```

## 插入排序
把数组的值往前插, 前面插入的数组是有序的. 已经有序的话只用遍历一次, 也就是$O(n)$, 否则还是需要$O(n^{2})$的时间. 如果排序是随机的, 可以计算到平均比较和移动次数是$n^{2}/4$. 和冒泡和选择相比, 插入排序性能会好一点.
```
//Java
public static void insertSort(int[] arr) {
    for (int i = 1; i < arr.length; i++) {
        int key = arr[i];
        int j = i - 1;
        while (j >= 0 && key < arr[j]) {
            arr[j + 1] = arr[j];
            j--;
        }
        arr[j + 1] = key;
    }
}
```

```
# Python
def insertsort(arr):
    for i in range(1, len(arr)):
        key = arr[i]
        j = i
        while j >= 1 and arr[j - 1] > key:
            arr[j] = arr[j - 1]
            j -= 1
        arr[j] = key
```

## 希尔排序(Shell Sort)
希尔排序好处就是在宏观的序列上排好了序, 在增量逐渐减小的序列上再排序. 是插入排序升级版, 防止小的数在数组末尾, 就会花很多时间插入. 移位法更加明显的体现了插入排序吗可以看出来形式和插入排序一模一样, 不过把gap从1变成了从大到小的动态gap. 时间复杂度$O(nlogn)$/$O(n^{3/2})$(有待考量, 一般说$O(n^{3/2})$适用于更广泛的增量序列.
```
// Java
// 交换(大话数据结构上的方法)
public static void shellSort(int[] arr) {
    for (int gap = arr.length / 2; gap > 0; gap /= 2) {
        for (int i = gap; i < arr.length; i++) {
            for (int j = i - gap; j <= arr.length - gap; j++) {
                if (arr[j] > arr[i]) {
                    int temp = arr[j];
                    arr[j] = arr[i];
                    arr[i] = temp;
                }
            }
        }
    }
}

// 移位(数据结构与算法分析上的方法)
public static void shellSort2(int[] arr) {
    for (int gap = arr.length / 2; gap > 0; gap /= 2) {
        for (int i = gap; i < arr.length; i++) {
            int j = i;
            int key = arr[j];
            while (j - gap >= 0 && key < arr[j - gap]) {
                arr[j] = arr[j - gap];
                j -= gap;
            }
            arr[j] = key;
        }
    }
}
```

```
# Python
def shellsort(arr):
    gap = len(arr) // 2
    while gap > 0:
        for i in range(gap, len(arr)):
            key = arr[i]
            j = i
            while j >= gap and arr[j - gap] > key:
                arr[j] = arr[j - gap]
                j -= gap
            arr[j] = key
        gap //= 2
```

## 快速排序
把数组分为两部分, 保证第一部分比第二部分小, 再接着分, 其实也是一种分治思想. 对于基准点的选择, 一般有三数取中的方法, 就是在三个数中取中间大小的那个数作为基准排序. 代码中我只是简单地取了第一个数. 如果partition每次都分的很均匀, 那么递归树的深度就是$log_{2}n+1$, 只需要递归$log_{2}n+$次, 递推就可以知道最好情况时间复杂度是$nlogn$. 最差就是逆序, 每次划分都是一个子序列和一个空的序列, 那么比较次数就是n-1+ n-2 + ... + 1, $O(n)$.
```
// Java
public static void quickSort(int[] arr, int left, int right) {
    if (left < right) {
        int p = partition(arr, left, right - 1);
        quickSort(arr, left, p);
        quickSort(arr, p + 1, right);
    }
}

public static int partition(int[] arr, int left, int right) {
    int p = arr[left];
    while (left < right) {
        while (left < right && arr[right] > p) right--;
        arr[left] = arr[right];
        while (left < right && arr[left] < p) left++;
        arr[right] = arr[left];
    }
    arr[left] = p;
    return left;
}
```

```
# Python
def quicksort(arr, left, right):
    if left < right:
        p = partition(arr, left, right)
        quicksort(arr, left, p);
        quicksort(arr, p + 1, right)

def partition(arr, left, right):
    k = arr[left]
    while left < right:
        while left < right and  arr[right] > k:
            right -= 1
        arr[left] = arr[right]
        while left < right and arr[left] < k:
            left += 1
        arr[right] = arr[left]
    arr[left] = k
    return left
```

## 堆排序
通过最小堆来排序序列, 每次把最小的取出来之后再做heapify, 直到取出所有点. 最好最坏平均时间复杂度都是$nlogn$, 因为取堆顶重建时间都是logi, 而最终需要取n-1次. 但是初始构建堆的时候需要多次比较, 所以如果序列个数比较少就划不来了.
```
// Java
public static void heapSort(int arr[], int n) {
    buildHeap(arr, n);
    for (int i = n - 1; i >= 0; i--) {
        swap(arr, i, 0);
        heapify(arr, i, 0);
    }
}

public static void buildHeap(int[] arr, int n) {
    int parent = (n - 2) / 2;
    for (int i = parent; i >= 0; i--) {
        heapify(arr, n, i);
    }
}

public static void swap(int[] arr, int i, int j) {
    int temp = arr[i];
    arr[i] = arr[j];
    arr[j] = temp;
}

public static void heapify(int[] arr, int n, int index) {
    if (index >= n) return;
    int c1 = 2 * index + 1;
    int c2 = 2 * index + 2;
    int max_index = index;
    if (c1 < n && arr[c1] > arr[max_index]) max_index = c1;
    if (c2 < n && arr[c2] > arr[max_index]) max_index = c2;
    if (max_index != index) {
        swap(arr, max_index, index);
        heapify(arr, n, max_index);
    }
}
```

```
# Python
def heapsort(arr, n):
    buildheap(arr, n);
    for i in range(n - 1, -1, -1):
        arr[i], arr[0] = arr[0], arr[i] 
        heapify(arr, i, 0)

def buildheap(arr, n):
    parent = (n - 2) // 2
    for i in range(parent, -1, -1):
        heapify(arr, n, i);

def heapify(arr, n, index):
    if index >= n:
        return
    m = index
    c1 = 2 * index + 1
    c2 = 2 * index + 2
    if c1 < n and arr[m] < arr[c1]:
        m = c1
    if c2 < n and arr[m] < arr[c2]:
        m = c2
    if m != index:
        arr[m], arr[index] = arr[index], arr[m]
        heapify(arr, n, m)
```

## 归并排序
归并排序用了分支的思想, 和堆排序一样, 利用了完全二叉树. 改进了冒泡排序(减少循环次数), 需要进行logn次循环, 每一趟都会进行n次扫描, 所以时间复杂度总是保持在$nlogn$. **经典的逆序对问题其实就可以通过归并排序的思想来做**.
```
// Java
public static void mergeSort(int[] arr, int start, int end) {
    if (start < end) {
        int mid  = (end + start) / 2;
        mergeSort(arr, start, mid);
        mergeSort(arr, mid + 1, end);
        merge(arr, start, mid, end);
    }
}

public static void merge(int[] arr, int start, int mid, int end) {
    int[] temp = new int[end - start + 1];
    int i = start, j = mid + 1, index = 0;
    while (i <= mid && j <= end) {
        temp[index++] = arr[i] <= arr[j] ? arr[i++] : arr[j++];
    }
    while (i <= mid) temp[index++] = arr[i++];
    while (j <= end) temp[index++] = arr[j++];
    for (int k = 0; k < temp.length; k++) arr[k + start] = temp[k];
}
```

```
# Python
def mergesort(arr, start, end):
    if start < end:
        mid = (start + end) // 2
        mergesort(arr, start, mid)
        mergesort(arr, mid+1, end)
        merge(arr, start, mid, end)

def merge(arr, start, mid, end):
    temp = []
    i = start
    j = mid + 1
    while i <= mid and j <= end:
        if arr[i] < arr[j]:
            temp.append(arr[i])
            i += 1
        else:
            temp.append(arr[j])
            j += 1   
    while i <= mid:
        temp.append(arr[i])
        i += 1
    while j <= end:
        temp.append(arr[j])
        j += 1         
    for k in range(len(temp)):
        arr[k + start] = temp[k]
```