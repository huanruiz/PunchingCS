## 98_验证二叉搜索树
利用二叉搜索树的性质, 中序遍历, 前一个节点的值必须小于现在的节点. 
```
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Solution:
    def isValidBST(self, root: TreeNode) -> bool:
        self.pre = float('-inf')
        def search(root):
            if root == None:
                return True
            if not search(root.left):
                return False
            if self.pre >= root.val:
                return False
            self.pre = root.val
            if not search(root.right):
                return False
            return True
        return search(root)
```

## 94_二叉树的中序遍历
用栈来存储已遍历的节点, 先向左搜索直到左边为空, 栈顶的节点就是当前子树的根, 于是再往右子树搜索.
```
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def inorderTraversal(self, root: TreeNode) -> List[int]:
        stack = []
        res = []
        while root or stack:
            while root:
                stack.append(root)
                root = root.left
           
            root = stack.pop()
            res.append(root.val)
            root = root.right
        return res
```

## 101_对称二叉树
1.根节点值相等; 2.左边的左子树与右边的右子树对称; 3.左边的右子树与右边的左子树对称.
```
# 递归
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Solution:
    def isSymmetric(self, root: TreeNode) -> bool:
        def dfs(p, q):
            if not p or not q:
                return not p and not q
            return p.val == q.val and dfs(p.left, q.right) and dfs(p.right, q.left)

        if root == None:
            return True
        return dfs(root.left, root.right)
```

```
# 迭代
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Solution:
    def isSymmetric(self, root: TreeNode) -> bool:
        if not root:
            return True
        lstack = []
        rstack = []
        l, r = root.left, root.right
        while l or r or len(lstack) > 0 or len(rstack) > 0:
            while l and r:
                lstack.append(l)
                l = l.left
                rstack.append(r)
                r = r.right

            if l or r:
                return False
            l = lstack.pop()
            r = rstack.pop()
            if l.val != r.val:
                return False

            l, r = l.right, r.left
        return True
```

## 105_从前序与中序遍历序列构造二叉树
```
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Solution:
    def buildTree(self, preorder: List[int], inorder: List[int]) -> TreeNode:
        self.pos = {}
        n = len(preorder)
        for i in range(n):
            self.pos[inorder[i]] = i
        def dfs(preorder, inorder, pl, pr, il, ir):
            if pl > pr:
                return None
            k = self.pos[preorder[pl]]
            val = preorder[pl]
            length = k - il
            root = TreeNode(val)
            root.left = dfs(preorder, inorder, pl + 1, pl + length, il, k - 1)
            root.right = dfs(preorder, inorder, pl + 1 + length, pr, k + 1, ir)
            return root
        return dfs(preorder, inorder, 0, n - 1, 0, n - 1)
```

106_中后:
```
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Solution: 
    def buildTree(self, inorder: List[int], postorder: List[int]) -> TreeNode:
        self.pos = {}
        n  = len(inorder)
        for i in range(n):
            self.pos[inorder[i]] = i
        def dfs(inorder, postorder, il, ir, pl, pr):
            if pl > pr:
                return None
            k = self.pos[postorder[pr]]
            val = postorder[pr]
            length = k - il
            root = TreeNode(val)
            root.left = dfs(inorder, postorder, il, k - 1, pl, pl + length - 1)
            root.right = dfs(inorder, postorder, k + 1, ir, pl + length, pr - 1)
            return root
        
        return dfs(inorder, postorder, 0, n - 1, 0, n - 1)
```

899_前后:

这个稍微有点不同, 前序的root后一位就是后序的左子树最后一位, 进而确定左子树大小
```
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Solution:
    def constructFromPrePost(self, pre: List[int], post: List[int]) -> TreeNode:
        self.pos = {}
        n = len(pre)
        for i in range(n):
            self.pos[post[i]] = i
        def dfs(pre, post, prl, prr, pol, por):
            if prl > prr:
                return None
            root = TreeNode(pre[prl])
            if prl == prr: # 防止越界
                return root

            index = self.pos[pre[prl + 1]]
            root.left = dfs(pre, post, prl + 1, prl + index - pol + 1, pol, index)
            root.right = dfs(pre, post, prl + index + 2 - pol, prr, index + 1, por - 1)
            return root
        return dfs(pre, post, 0, n - 1, 0, n - 1)
```

## 102_二叉树的层序遍历
```
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Solution:
    def levelOrder(self, root: TreeNode) -> List[List[int]]:
        res = []
        if root == None:
            return res
        queue = [root]
        while queue:
            size = len(queue)
            level = []
            for i in range(size):
                node = queue.pop(0)
                if node.left:
                    queue.append(node.left)
                if node.right:
                    queue.append(node.right)
                level.append(node.val)
            res.append(level)
        return res
```

## 236_二叉树的最近公共祖先
左为空, 则在右子树, 右为空, 则在左子树. 否则在root.
```
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Solution:
    def lowestCommonAncestor(self, root: 'TreeNode', p: 'TreeNode', q: 'TreeNode') -> 'TreeNode':
        if root == None or root == p or root == q:
            return root
        left = self.lowestCommonAncestor(root.left, p, q)
        right = self.lowestCommonAncestor(root.right, p, q)

        if not left:
            return right
        elif not right:
            return left
        else:
            return root
```

## 543_二叉树的直径
左子树的最大值加右子树的最大值
```
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Solution:
    def diameterOfBinaryTree(self, root: TreeNode) -> int:
        self.res = 0
        def dfs(root):
            if root == None:
                return 0
            left = dfs(root.left)
            right = dfs(root.right)
            self.res = max(self.res, left + right)
            return max(left + 1, right + 1)
        dfs(root)
        return self.res
```

## 124_二叉树中的最大路径和
注意子路径的和为负, 直接不用计算, 因为我们计算了所有res的值, 所以并不会错过其中的负值
```
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Solution:
    def maxPathSum(self, root: TreeNode) -> int:
        self.res = float('-inf')

        def dfs(root):
            if root == None:
                return 0
            left = dfs(root.left)
            right = dfs(root.right)
            self.res = max(self.res, left + right + root.val)
            return max(left + root.val, right + root.val, 0)
        dfs(root)
        return self.res
```

## 173_二叉搜索树迭代器
和之前的中序遍历一样的, 只不过这里吧步骤拆开了.
```
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class BSTIterator:

    def __init__(self, root: TreeNode):
        self.stack = []
        while root != None:
            self.stack.append(root)
            root = root.left

    def next(self) -> int:
        """
        @return the next smallest number
        """
        node = self.stack.pop()
        res = node.val
        node = node.right
        while node:
            self.stack.append(node)
            node = node.left
        return res

    def hasNext(self) -> bool:
        """
        @return whether we have a next smallest number
        """
        return len(self.stack) > 0

# Your BSTIterator object will be instantiated and called as such:
# obj = BSTIterator(root)
# param_1 = obj.next()
# param_2 = obj.hasNext()
```

## 297_二叉树的序列化与反序列化
叶子节点加#代表None, 字符串和数值要用成员变量来表示.
```
# Definition for a binary tree node.
# class TreeNode(object):
#     def __init__(self, x):
#         self.val = x
#         self.left = None
#         self.right = None

class Codec:

    def serialize(self, root):
        """Encodes a tree to a single string.
        
        :type root: TreeNode
        :rtype: str
        """
        self.res = ""
        self.dfs1(root)
        return self.res

    def dfs1(self, root):
        if not root:
            self.res += "#,"
            return
        self.res += str(root.val) + ','
        self.dfs1(root.left)
        self.dfs1(root.right)
        
    def deserialize(self, data):
        """Decodes your encoded data to tree.
        
        :type data: str
        :rtype: TreeNode
        """
        self.u = 0
        return self.dfs2(data)
    
    def dfs2(self, data):
        if data[self.u] == '#':
            self.u += 2 # #和,
            return None

        is_minus = False
        if data[self.u] == '-':
            is_minus = True
            self.u += 1
        t = 0
        while data[self.u] != ',':
            t = t * 10 + int(data[self.u])
            self.u += 1
        self.u += 1
        if is_minus: t = -t

        root = TreeNode(t)
        root.left = self.dfs2(data)
        root.right = self.dfs2(data)
        return root

# Your Codec object will be instantiated and called as such:
# ser = Codec()
# deser = Codec()
# ans = deser.deserialize(ser.serialize(root))
```