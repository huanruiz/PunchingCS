## 19_删除链表的倒数第N个节点  
用虚拟头结点, 倒数的节点用双指针
```
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None

class Solution:
    def removeNthFromEnd(self, head: ListNode, n: int) -> ListNode:
        h = ListNode(-1)
        h.next = head

        p = h
        q = h
        for i in range(n):
            q = q.next
        while q.next != None:
            p = p.next
            q = q.next

        p.next = p.next.next
        return h.next # 用虚拟头结点就不用判断是否为None了
```

## 237_删除链表中的节点
输入直接是node, 直接用该node复制下一个node并跳过下一个node即可.
```
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None

class Solution:
    def deleteNode(self, node):
        """
        :type node: ListNode
        :rtype: void Do not return anything, modify node in-place instead.
        """
        node.val= node.next.val
        node.next = node.next.next
```

## 83_删除排序链表中的重复元素
分相同和不同两种情况.
```
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None

class Solution:
    def deleteDuplicates(self, head: ListNode) -> ListNode:
        p = head
        while p:
            if p.next and p.next.val == p.val:
                p.next = p.next.next
            else:
                p = p.next
        return head
```

## 61_旋转链表
head会改变, 需要虚拟指针. 因为改变的节点较多, 所以直接用a, b来存储.
```
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None

class Solution:
    def swapPairs(self, head: ListNode) -> ListNode:
        dummy = ListNode(-1)
        dummy.next = head
        p = dummy
        while p.next and p.next.next:
            a, b = p.next, p.next.next
            tmp = b.next
            p.next = b
            b.next = a
            a.next = tmp
            p = a
        return dummy.next
```

## 206_反转链表
```
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None

class Solution:
    def reverseList(self, head: ListNode) -> ListNode:
        a = None
        b = head
        while b:
            tmp = b.next
            b.next = a
            a = b
            b = tmp
        return a
```

## 92_反转链表II
在普通的反转链表上增加了范围, 用start和end指针去捕捉头尾的前一个节点, 用于反转后再连接
```
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None

class Solution:
    def reverseBetween(self, head: ListNode, m: int, n: int) -> ListNode:
        dummy = ListNode(-1)
        dummy.next = head
        start, end = dummy, dummy

        for _ in range(m - 1): start = start.next
        for _ in range(n): end = end.next
        
        a = start.next
        b = end.next

        p, q = a, a.next
        for i in range(n - m):
            tmp = q.next
            q.next = p
            p = q
            q = tmp

        a.next = b
        start.next = end
        return dummy.next
```
## 160_相交链表
注意a, b指针要能到None, 否则不相交的链表无法退出while循环.
```
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None

class Solution:
    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> ListNode:
        a = headA
        b = headB

        while a != b:
            a = a.next if a != None else headB
            b = b.next if b != None else headA
        return a
```

## 142_环形链表II
快慢指针, 当两者相遇, 把快指针放在head, 两者步长为1继续遍历链表, 再次相遇时这个点就是链表的起点.
```
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, x):
#         self.val = x
#         self.next = None

class Solution:
    def detectCycle(self, head: ListNode) -> ListNode:
        slow = head
        fast = head
        while fast:
            fast = fast.next
            slow = slow.next
            if fast:
                fast = fast.next
            else:
                return None
            if slow == fast:
                fast = head
                while fast != slow:
                    fast = fast.next
                    slow = slow.next
                return fast
```

### 148_排序链表
