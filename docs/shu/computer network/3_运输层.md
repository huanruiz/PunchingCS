# 运输层
运输层协议为运行在不同的主机上的应用进程之间提供了逻辑通信(logic communication), 它是在端系统中被实现的, 发送端的运输层把报文转换为**报文段(segment)**(为了避免混淆, 把数据报这个名字给网络层), 并将报文段传输给网络层, 网络层将其封装为网络层分组(数据报)并向目的的发送, 注意网络层是不会检查报文段的. 接收端的网络层从数据报中提取运输层报文段, 并将该报文段上交给运输层, 运输层处理报文段, 把其中的数据为接受应用进程所使用.

## 概述
### 运输层与网络层关系
网络层提供了主机之间的逻辑通信, 而运输层提供了主机之间不同进程的逻辑通信, 运输层协议往往受制于网络层协议, 但是即使网络层协议不可靠(有分组丢失, 篡改, 冗余). 运输层也能为应用程序提供可靠的运输服务. 

### 因特网运输层概述
主要就是**TCP和UDP**两种协议. 需要注意的是, IP是不可靠服务, 只能保证尽力交付, 而TCP/UDP最基本的任务就是讲两个端系统间的IP交付任务扩展为运行在端系统上的连个进程之间的交付任务. 这个扩展交付的名字叫**运输层的多路复用(transport-layer multiplexing)**和**多路分解(demultiplexing)**. TCP/UDP还可以通过报文段首部中的差错检查字段来提供**完整性检查**.  **进程到进程的数据交付和差错检查就是两种最低限度运输层服务**, 所以不可靠的UDP就可以提供. 而**TCP提供可靠数据传输, 并且还提供了阻塞控制(congestion control)**

## 多路复用和多路分解
运输层检查报文段中的字段, 标识出接受socket, 进而将报文段定向到嵌套字, 并将**运输层报文段中的数据**交付到正确的socket的工作叫**多路分解**, 源主机从不同socket中收集数据块, 为每个数据块封装首部信息(为了后面的分解)并生成报文段, 把报文段传递给网络层就是**多路复用**. 多路复用的要求是**socket有唯一的标识符**/**每个报文段有特殊字段指示其要交付的socket**. 

下图是报文段的大致结构. 其中, 端口号是16bit的数, 其中0~1023范围内是**周知端口号(weel-known port number)**, 此端口号受限制, 保留给HTTP(80), FTP(21)等周知的应用层协议使用. 主机上的每个socket都能分配一个端口号, 当报文段到达主机时, 运输层检查报文段中的端口号并将其定向到socket, 报文段中的数据就通过socket进入其所连接的进程.
![](https://github.com/huanruiz/PunchingCS/blob/master/images/cn3_1.png)

### 无连接的路复用和多路分解
python实现的socket中, 可以有两种方法, 一种是为运输层为某个socket自动分配一个端口号(1024~65535中选个没有使用的), 一种是手动``bind()``一个, 如果是周知协议的服务端, 那么必需分配指定的端口号了. 一个UDP socket包含了``(目的IP, 目的端口号)``这样的二元组, 所以即使源不相同但是目的相同, 他们会用相同的socket, 并分配到相同的进程. 源端口号只是作为返回地址的一部分来返回信息, 为什么说是返回地址的一部分呢, 因为它没有包含IP地址. **而原端口号和源IP是层层封装到数据报中的**.

### 面向连接的路复用和多路分解
TCP相较于UDP的区别就是socket是由``(源IP, 源端口号, 目的IP, 目的端口号)``这样的四元组标识的 ,所以主机收到数据报时, 会通过这四个值来把报文段分解到对应的socket. 

### Web服务器与TCP
要注意的是, 连接socket和进程可能不是一一对应的关系, 有可能一些socket对应的是同一个进程下的不同线程.

## UDP
DNS就是使用UDP的例子, 当主机的DNS程序想查询时, 它会构造DNS擦汗讯报文给UDP, UDP为其加上首部字段, 形成数据报并给网络层, 网络层再将其封装到IP数据报中. UDP的区别于TCP的特点如下:
- 应用层控制更加精细, 不用担心阻塞控制, 不过分关心数据丢失
- 无需连接简历, 没有三次握手的时延, 这也是为什么DNS协议用UDP
- 无连接状态, 不用追踪序号确认号等参数, 一般相较TCP能支持更多活跃用户
- 分组首部开销小, UDP只需要8个byte, TCP需要20个byte

### UDP报文段结构
![](https://github.com/huanruiz/PunchingCS/blob/master/images/cn3_2.png)

**长度字段**表示UDP报文段的字节数(首部加数据), 检验和是为了接收端检查报文段是否有错误. 

### UDP检验和
接收方把4个16bit字段加在一起, 若没有差错则在接受方的和应该为``1111111111111111``. 因为传输过程中的链路和路由器不能保证没有差错, 所以UDP就必须在端到端的基础上在运输层提供差错检测, 这就是**端到端原则(end-end principle)**. 注意UDP可以检测差错但不能恢复.

## 可靠数据传输原理
可靠运输不仅仅是运输层的事, 所以这里我们不讲报文段, 而是用更通用的说法: 分组. 并且下面仅考虑单向传输.

### 构建可靠传输协议
接下来一步步的介绍这些协议的更迭.

#### 经完全可靠信道的可靠数据传输: rdt1.0
下图就是rdt1.0的有限状态机(FSM), 
![](https://github.com/huanruiz/PunchingCS/blob/master/images/cn3_3.png)

**todo**

## TCP
TCP依赖上一节的许多基本原理, 包括差错检测, 重传, 累积确认, 定时器和用于序号和确认号的首部字段.

### TCP连接
TCP是面向连接的, 提供全双工服务