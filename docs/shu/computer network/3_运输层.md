# 运输层
运输层协议为运行在不同的主机上的应用进程之间提供了逻辑通信(logic communication), 它是在端系统中被实现的, 发送端的运输层把报文转换为**报文段(segment)**(为了避免混淆, 把数据报这个名字给网络层), 并将报文段传输给网络层, 网络层将其封装为网络层分组(数据报)并向目的的发送, 注意网络层是不会检查报文段的. 接收端的网络层从数据报中提取运输层报文段, 并将该报文段上交给运输层, 运输层处理报文段, 把其中的数据为接受应用进程所使用.

## 概述
### 运输层与网络层关系
网络层提供了主机之间的逻辑通信, 而运输层提供了主机之间不同进程的逻辑通信, 运输层协议往往受制于网络层协议, 但是即使网络层协议不可靠(有分组丢失, 篡改, 冗余). 运输层也能为应用程序提供可靠的运输服务. 

### 因特网运输层概述
主要就是**TCP和UDP**两种协议. 需要注意的是, IP是不可靠服务, 只能保证尽力交付, 而TCP/UDP最基本的任务就是讲两个端系统间的IP交付任务扩展为运行在端系统上的连个进程之间的交付任务. 这个扩展交付的名字叫**运输层的多路复用(transport-layer multiplexing)**和**多路分解(demultiplexing)**. TCP/UDP还可以通过报文段首部中的差错检查字段来提供**完整性检查**.  **进程到进程的数据交付和差错检查就是两种最低限度运输层服务**, 所以不可靠的UDP就可以提供. 而**TCP提供可靠数据传输, 并且还提供了阻塞控制(congestion control)**

## 多路复用和多路分解
运输层检查报文段中的字段, 标识出接受socket, 进而将报文段定向到嵌套字, 并将**运输层报文段中的数据**交付到正确的socket的工作叫**多路分解**, 源主机从不同socket中收集数据块, 为每个数据块封装首部信息(为了后面的分解)并生成报文段, 把报文段传递给网络层就是**多路复用**. 多路复用的要求是**socket有唯一的标识符**/**每个报文段有特殊字段指示其要交付的socket**. 

下图是报文段的大致结构. 其中, 端口号是16bit的数, 其中0~1023范围内是**周知端口号(weel-known port number)**, 此端口号受限制, 保留给HTTP(80), FTP(21)等周知的应用层协议使用. 主机上的每个socket都能分配一个端口号, 当报文段到达主机时, 运输层检查报文段中的端口号并将其定向到socket, 报文段中的数据就通过socket进入其所连接的进程.
![](https://github.com/huanruiz/PunchingCS/blob/master/images/cn3_1.png)

### 无连接的路复用和多路分解
python实现的socket中, 可以有两种方法, 一种是为运输层为某个socket自动分配一个端口号(1024~65535中选个没有使用的), 一种是手动``bind()``一个, 如果是周知协议的服务端, 那么必需分配指定的端口号了. 一个UDP socket包含了``(目的IP, 目的端口号)``这样的二元组, 所以即使源不相同但是目的相同, 他们会用相同的socket, 并分配到相同的进程. 源端口号只是作为返回地址的一部分来返回信息, 为什么说是返回地址的一部分呢, 因为它没有包含IP地址. **而原端口号和源IP是层层封装到数据报中的**.

### 面向连接的路复用和多路分解
TCP相较于UDP的区别就是socket是由``(源IP, 源端口号, 目的IP, 目的端口号)``这样的四元组标识的 ,所以主机收到数据报时, 会通过这四个值来把报文段分解到对应的socket. 

### Web服务器与TCP
要注意的是, 连接socket和进程可能不是一一对应的关系, 有可能一些socket对应的是同一个进程下的不同线程.

## UDP
DNS就是使用UDP的例子, 当主机的DNS程序想查询时, 它会构造DNS擦汗讯报文给UDP, UDP为其加上首部字段, 形成数据报并给网络层, 网络层再将其封装到IP数据报中. UDP的区别于TCP的特点如下:
- 应用层控制更加精细, 不用担心阻塞控制, 不过分关心数据丢失
- 无需连接简历, 没有三次握手的时延, 这也是为什么DNS协议用UDP
- 无连接状态, 不用追踪序号确认号等参数, 一般相较TCP能支持更多活跃用户
- 分组首部开销小, UDP只需要8个byte, TCP需要20个byte

### UDP报文段结构
![](https://github.com/huanruiz/PunchingCS/blob/master/images/cn3_2.png)

**长度字段**表示UDP报文段的字节数(首部加数据), 检验和是为了接收端检查报文段是否有错误. 

### UDP检验和
接收方把4个16bit字段加在一起, 若没有差错则在接受方的和应该为``1111111111111111``. 因为传输过程中的链路和路由器不能保证没有差错, 所以UDP就必须在端到端的基础上在运输层提供差错检测, 这就是**端到端原则(end-end principle)**. 注意UDP可以检测差错但不能恢复.

## 可靠数据传输原理
可靠运输不仅仅是运输层的事, 所以这里我们不讲报文段, 而是用更通用的说法: 分组. 并且下面仅考虑单向传输.

### 构建可靠传输协议
接下来一步步的介绍这些协议的更迭.

#### 经完全可靠信道的可靠数据传输: rdt1.0
下图就是rdt1.0的有限状态机(FSM), 
![](https://github.com/huanruiz/PunchingCS/blob/master/images/cn3_3.png)

**todo**

## TCP
TCP依赖上一节的许多基本原理, 包括差错检测, 重传, 累积确认, 定时器和用于序号和确认号的首部字段.

### TCP连接 
TCP是面向连接的, 提供**全双工服务(full-duplex service)**, 是**点对点**的. **注意TCP和电路交换中端到端的TDM和FDM电路是两回事, TCP的连接状态完全保留在两个端系统中, 不在中间的网路元素中(路由器和链路层交换机)中运行**. 而TCP连接就是经典的**三次握手**.

一旦连接成功, 客户进程就可以通过socket传递数据流, TCP拿到了数据流就把他们引导到**发送缓存(send buffer)**中, TCP就能在合适的时间以报文段的形式发送这些数据. TCP可从缓存中取出并放入报文段中的数据数量受限于**最大报文长度(Maximun Segment Size MSS)**. MSS通常由最**大链路层帧长度(Maximum Transmission Unit MTU)**来设置. TCP为每块用户数据加上首部, 形成TCP报文段. TCP报文段被下传到网络层, 网络层将其分别封装在IP数据报中, 通过网络发送. 而在接收端, 收到了这些报文段数据之后, 就会放进TCP接收缓存. 如下图, 进一步证明了TCP连接只包含了这两台主机的缓存, 变量和socket, 而网络中的路由器/交换机/中继器没有为TCP连接分配任何缓存和变量.
![](https://github.com/huanruiz/PunchingCS/blob/master/images/cn3_4.png)

### TCP报文段结构
![](https://github.com/huanruiz/PunchingCS/blob/master/images/cn3_5.png)
由首部字段和数据字段组成. 而MSS限制的其实就是数据字段的最大长度, 大文件会被切分成多个MSS块, 而交互式应用的传递长度往往会小于1个MSS. TCP班文段首部一般是20个字节.

- 源端口号和目的端口号可以用于多路复用和多路分解
- 32bit的**序号字段(sequence number field)**和**确认号字段(acknowledge number field)**来保证可靠数据传输服务. 
- 16bit**接收窗口字段(header length field)**用于流量控制.
- 4bit**首部长度字段(header length field)**指示32bit的首部长度, 因为首部的长度是可变的, 一般就是20字节.
- 可选与变长的**选项字段(options field)**用于发送方和接收方协商MSS.
- 6bit**标志字段(flag field)**包含ACK比特(指示确认字段中的值是有效的), RST, SYN和FIN比特用于连接的建立和拆除, PSH比特被设置就表明接收方因立即把数据交给上层, URG比特表示报文段中存在着被发送端上层实体设置为紧急的数据, 紧急数据的最后一个byte由16bit的紧急数据指针字段指出. 实际中PSH, URG和紧急数据指针没有使用(书里面的确是这么写的). 

#### 序号和确认号
TCP把数据看成无结构的, 有序的字节流. **而序号就建立在字节流上, 而非传送的报文段序列上**. 报文段的序号就是该报文段首字节的字节流编号. 如下图500000byte的文件, MSS是1000byte, 那么其中0, 1000, ...就是相应TCP报文段首部的序号字段.
![](https://github.com/huanruiz/PunchingCS/blob/master/images/cn3_6.png)

**主机B填进报文段的确认号是期望从主机A收到的下一字节的序号**, 比如B收到了A发送的0~535的个字节, B就会等待A的数据流中536及以后的所有字节, 所以确认号字段就是536. 但是如果B收到了0~535和536~899的字节流, 确认号依然是536, 因为B只会确认流中第一个丢失字节为止的字节, 这就是TCP的**累计确认(cumulative acknowledgment)**. 而RFC其实没有规定中间丢失的报文段怎么处理, 这一部分是留给开发的事. 要么丢弃失序的报文段, 要么等待缺少的字节, 因为后者对网络带宽更有效, 在实践中常被采用.

下图是Telnet的例子, B收到了Seq=42表示已经成功收到了42及以前的byte, 所以ACK=43作为回复, 表示还要43byte以后的数据. 返回'C'是Telnet的回显, 保证用户发送的字符被服务器接收.第三个报文段唯一目的是确认A已从B收到数据, 该报文段数据字段空.
![](https://github.com/huanruiz/PunchingCS/blob/master/images/cn3_7.png)

### 往返时间的估计与超时
超时重传机制的这个超时时间是必须大于一个往返时间RTT的, 估计这个时间就显得尤为重要. 一个报文段的样本RTT就是从报文段发出(交给IP)到收到确认的时间. 大多数TCP在某一个时刻测量一个SampleRTT(不能测量重传的报文段), 加权平均的公式为$EstimatedRTT = (1-\alpha)\cdot EstimatedRTT + \alpha\cdot SampleRTT$, 在RFC6298中给$\alpha$的参考值是0.125.

测量RTT的变化在RFC6298中的公式为$DevRTT = (1-\beta)\cdot DevRTT + \beta\cdot |SampleRTT-EstimatedRTT|$, $\beta$推荐值是0.25.

那么, 超时重传的间隔就是$TimeInterval=EstimantedRTT + 4\cdot DevRTT$, 初始值为1, 同时考虑了时间及其波动. (有点像自动控制的pid).

### 可靠数据传输
#### 例子
图3-36避免了图3-35中Seq=92的2次传输.
![](https://github.com/huanruiz/PunchingCS/blob/master/images/cn3_8.png)
![](https://github.com/huanruiz/PunchingCS/blob/master/images/cn3_9.png)

#### 超时间隔加倍
每次TCP重传都将会让下一次的TimeInterval加倍, 防止网络阻塞导致源持续重传, 让阻塞加重.

#### 快速重传
超时重传带来的问题是提个报文段丢失时, 发送方会延迟重传丢失的分组, 增加端到端时延. 而接收端收到3个冗余ACK后, 就会在该报文段的定时器国企前重传丢失的报文段.
![](https://github.com/huanruiz/PunchingCS/blob/master/images/cn3_10.png)

#### 回退N步还是选择重传
TCP有**选择确认**机制, 让TCP接收方有选择地确认失序报文段, 而不是累计地确认最后一个正确接收的有序报文段, 从而忽略已经成功接受的报文段. 

### 流量控制
TCP为应用程序提供了**流量控制服务(flow-control service)**来消除发送方使接收方缓存溢出的可能性. 流量控制目的是匹配发送方的发送速率与接受方app的读取速率. TCP靠两端的发送方**接收窗口(receive window)**来提供流量控制, 其指示了接收方还有多少可用的缓存空间. 在传输文件的例子中, 我们仅研究接收窗口. A通过TCP向B发送大文件, B为该文件分配大小为RcvBuffer的接收缓存. 定义LastByteRead是B上的app从缓存读出的数据流的最后一个字节的编号, LastByteRcvd是


