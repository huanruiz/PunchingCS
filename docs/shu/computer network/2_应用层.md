# 应用层
## 协议管理
### 网络应用体系结构
有应用体系结构决定如何在端系统组织该应用程序. 包括客户-服务器体系结构和P2P体系结构.
- 客户-服务器体系结构: 主机总是打开服务其他客户主机的请求, 比如Web应用程序. 客户之间不会通信. 服务器具有固定, 周知的IP地址. 较大的应用会有配备大量主机的有数据中心.
- P2P: 对数据中心的服务器依赖小或者不依赖. 应用程序(对等方)在间断连接的主机之间直接通信. P2P具有**自扩展性(self-scalability)**. 

### 进程通行
相同端系统进程通信由操作系统确定. 不同的端系统进程通过端系统互相通信.
1. 客户和服务器进程: 发起通信为客户, 等待联系的是服务器. 
2. 进程与计算机网络的接口. 进程通过socket的软件接口向网络发送报文或从网络接收报文. 应用开发对运输层的控制仅限于选择运输层协议/设定几个运输层参数.
3. 进程寻址: 也就是寻找目的地地址, 需要**主机的地址**(IP地址)和定义在目的主机的接收进程的**标识符**(端口号).

### 供app使用的运输服务
选择运输层协议只有合不合适, 没有好不好. 我们从4个角度对app服务进行分类, 不要忘记这是针对运输层的.
1. 可靠数据传输: app是否是loss-tolerant的, 比如多媒体应用丢失疑点数据就影响不大.
2. 吞吐量: 网络路径的进程通信的场景中, 可用吞吐量就是发送进程能够向接收进程交付比特的速率. 有吞吐量要求的应用叫**带宽敏感(bandwidth sensitive)应用**, 比如多数的自媒体应用. 否则是弹性(elastic)应用, 如电子邮件等.
3. 定时: 运输层提供实时保证, 比如打游戏就不能延迟太高.
4. 安全性: 运输协议是否可以加密, 解密.

### 因特网的运输服务
- TCP: 面向连接, 可靠, 就有阻塞控制机制.
- UDP: 轻量, 不保证报文能到达接受进程, 也不保证顺序, 没有阻塞控制机制.
![](https://github.com/huanruiz/PunchingCS/blob/master/images/cn2_1.png)

### 应用层协议
应用层协议只是网络应用的一部分, 协议规定了进行报文的通信, 定义了:
1. 交换报文的类型, 如请求报文和响应报文
2. 豹纹的类型和语法, 如报文中的各个字段和这些字段是如何描述的
3. 字段包含信息的含义
4. 进程何时已经如何发送报文, 对报文进行响应的规则

下面介绍各种网络应用及协议.

## Web和HTTP
Web有**按需操作**的特点.
### HTTP
Web的应用层协议是**HTTP(HyperText Transfer Protoocol)**, HTTP由客户端程序和服务器程序共同实现. web页面由对象(包括html, jepg, java小程序等等)组成. html用过对象的url地址引用页面中的其他对象, 每个url由存放对象的服务器主机名和对象路径名组成. url地址http://www.bilibili.com/gakki_husband/harry.gif中, www.bilibili.com就是主机名, /gakki_husband/harry.gif就是路径名. web browser实现了客户端, web server实现了服务器端, 用于存储web对象, 每个对象由url寻址.

HTTP用TCP作为运输协议, 而HTTP本身是无状态协议, HTTP服务器不保存客户的信息.

### 非持续链接和持续链接
HTTP既可以非持续链接, 也可以持续链接. 
1. 非持续链接: 每个TCP链接在服务器发送一个对象后关闭, 每个TCP链接只传输一个请求报文和一个响应报文. 下面的步骤会产生11个TCP链接.
![](https://github.com/huanruiz/PunchingCS/blob/master/images/cn2_2.png)

客户请求基本文件到该客户收到整个文件所花费的时间叫**Round-Trip Time(RTT)**, 包括分组传播时延, 中间路由器和交换机上的排队时延和分组处理时延. 

**三次握手**的过程如下图. 总的响应时间就是2*RTT+服务器传输HTML文件的时间. 也就是说每次连接都会有第一个发起连接的RTT.
![](https://github.com/huanruiz/PunchingCS/blob/master/images/cn2_3.png)

2. 持续链接: 服务器在发送响应后保持TCP打开, 用过相同链接传输上面提到的HTML基本文件和10个图形, 如果一段时间不使用这条链接, 则HTTP服务器关闭连接. 

### HTTP报文格式
#### 请求报文
```
GET /somedir/page.html HTTP/1.1
Host: www.someschool.com
onnection: close
User-agent: Mozilla/5.0
Accept-language: fr
```
**每行由回车和换行符结束, 最后一行附加回车和换行符**(我曾经在lab中因为不清楚这点debug了一下午), HTTP请求的第一行为**请求行(request line)**, 后继的行叫做**首部行(header line)**. 

- 请求行包括**方法字段(GET/POST/HEAD/PUT/DELETE)**, **URL字段**, **HTTP版本字段**; 图中的例子就是GET了/somedir/page.html这个对象.
- 首部行``Host: www.someschool.com``, 看似没必要, 但是实际上是Web代理高速缓存所要求的. ``Connection: close``就是非持续链接. ``User-agent: Mozilla/5.0``指明了用户代理(向服务器发送请求的浏览器类型). ``Accept-language: fr``首部行表示用户想要法语.

下图就是请求报文的通用格式, 后面有个实体主题entity body. 用GET方法时为空, **可是当用户提交表单时常常用POST方法, 而表单的输入就在实体主体中**. 当然请求的url也可以包含这个数据, 比如在b站搜石原里美, 浏览器的url就成了``search.bilibili.com/all?keyword=石原里美``, **但是header里面的url不是这个, 为什么呢?**
![](https://github.com/huanruiz/PunchingCS/blob/master/images/cn2_4.png)

HEAD类似GET, 服务器会使用HTTP报文响应, 但不返回请求对象, 可以用来调试跟踪. PUT一般和Web发行工具一起用, 允许用户上传对象到指定服务器目录, 需要向Web服务器上传对象的app也可以用PUT. DELETE则是删除Web服务器的对象.

### 响应报文
```
HTTP/1.1 200 OK
Connection: close
Date: Tue, 09 Aug 2011 15:44:04 GMT
Server: Apache/2.23 (CentOS)
Last-Modified: Tue, 09 Aug 2011 15:11:03 GMT
Content-Length: 6821
Content-Type: text/html

(data data data...)
```
响应报文分为一个**状态行(status line)**, 6个**首部行(header line)**, **实体体(entity body)**. 实体体是报文的主要部分, 包含请求对象本身. 状态行有三个字段: 协议版本, 状态码, 状态信息.

首部行中``Connection: close``表示非持续连接, 发送报文后关闭连接. ``Date: Tue, 09 Aug 2011 15:44:04 GMT``是服务器在文件系统中检索到对象, 插入到响应报文, 被发送该响应报文的时间. ``Server: Apache/2.23 (CentOS)``表示该报文是Apache Web服务器产生的. ``Last-Modified: Tue, 09 Aug 2011 15:11:03 GMT``表示对象最后的修改时间. ``Content-Length: 6821``表示被发送对象中的字节数. ``Content-Type: text/html``表示实体体中的对象是HTML文本, 注意对象类型应该用``Content-Type``来指示而不是用文件扩展名.
![](https://github.com/huanruiz/PunchingCS/blob/master/images/cn2_5.png)

