并查集, 我是直接改的 https://leetcode-cn.com/problems/redundant-connection-ii/solution/python-jian-ji-dai-ma-bing-cha-ji-de-yun-yong-by-y/ 的答案. 分为有入度为2的点和无入度为2的点两种情况.
```
class DisJoinSet:
    def __init__(self, N):
        self.pa = list(range(N + 1))
    
    def find_root(self, x):
        if x != self.pa[x]:
            self.pa[x] = self.find_root(self.pa[x])
        return self.pa[x]
    
    def union(self, x, y):
        root_x = self.find_root(x)
        root_y = self.find_root(y)
        if root_x != root_y:
            self.pa[root_x] = root_y
            return True
        else:
            return False

class Solution:
    def findRedundantDirectedConnection(self, edges: List[List[int]]) -> List[int]:
        n = len(edges)
        # 检查是否存在入度为2的结点
        cnt = [0] * ( n + 1)
        for s, e in edges:
            cnt[e] += 1
        node = 0
       # cnt中的索引对应是图中的结点， 编号：1~N
        for idx, num in enumerate(cnt):
            if num == 2:
                node = idx
                break

        # 情况1：如果不存在入度为2的点，做法和冗余连接1一样
        if node == 0:
            # 实例化一个并查集
            utf = DisJoinSet(n)
            for s, e in edges:
                if not utf.union(s, e):
                    # 合并失败，说明加入这条边后，就存在环了，此时这条边就是答案了
                    return [s, e]
        
        # 情况2：如果存在入度为2的点
        if node != 0:
            utf = DisJoinSet(n)
            # 找到与入度为2的点相连的两条边，因为只添加一条额外边，所以在
            # delete长度为2时，结束循环
            delete = []
            for s, e in edges:
                if e == node:
                    delete.append([s, e])
                    if len(delete) > 1:
                        break
            # 题目要求删除最后出现的边，选择delete中的最后一个元素 
            last_s, last_e = delete[-1]
            edges.remove([last_s, last_e])
            for s, e in edges:
                if not utf.union(s, e):
                    return [delete[0][0], delete[0][1]]
            return [last_s, last_e]
```