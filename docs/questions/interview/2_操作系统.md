# LRU LFU
LRU，最近最少使用，把数据加入一个链表中，按访问时间排序，发生淘汰的时候，把访问时间最旧的淘汰掉。
比如有数据 1，2，1，3，2
此时缓存中已有（1，2）
当3加入的时候，得把后面的2淘汰，变成（3，1）

LFU，最近不经常使用，把数据加入到链表中，按频次排序，一个数据被访问过，把它的频次+1，发生淘汰的时候，把频次低的淘汰掉。
比如有数据 1，1，1，2，2，3
缓存中有（1(3次)，2(2次)）
当3加入的时候，得把后面的2淘汰，变成（1(3次)，3(1次)）
区别：LRU 是得把 1 淘汰。

显然
LRU对于循环出现的数据，缓存命中不高
比如，这样的数据，1，1，1，2，2，2，3，4，1，1，1，2，2，2.....
当走到3，4的时候，1，2会被淘汰掉，但是后面还有很多1，2

LFU对于交替出现的数据，缓存命中不高
比如，1，1，1，2，2，3，4，3，4，3，4，3，4，3，4，3，4......
由于前面被（1(3次)，2(2次)）
3加入把2淘汰，4加入把3淘汰，3加入把4淘汰，然而3，4才是最需要缓存的，1去到了3次，谁也淘汰不了它了。

## 输入url到页面加载发生了什么
https://segmentfault.com/a/1190000006879700

## 三次握手 四次挥手
https://blog.csdn.net/qzcsu/article/details/72861891

## 表student_score 字段:name, course, score 求 每个人考的最好的一门
select  
a.course,a.name
from student_score  a 
join (select max(score) max_score, name from student_score group by name) b
on a.name = b.name and a.score = b.max_score;

## 最小生成树 Prim Kruskal
https://zhuanlan.zhihu.com/p/34922624

## https
https://segmentfault.com/a/1190000019976390

## 操作系统
